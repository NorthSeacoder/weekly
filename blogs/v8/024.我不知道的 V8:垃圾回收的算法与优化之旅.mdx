---
tags: [前端开发, V8, JavaScript, 垃圾回收, 性能优化]
category: V8
date: 2024-03-17
title: 我不知道的 V8:垃圾回收的算法与优化之旅
desc: 深入 V8 的垃圾回收算法，剖析新生代老生代与优化的底层逻辑。
slug: v8-js-engine-24
---


V8 引擎的高效运行离不开其垃圾回收（GC）机制。从标记-清除到新生代老生代的世代管理，V8 如何清理内存并优化性能？今天，我们将从垃圾回收的背景出发，深入揭开 V8 的两大回收算法与世代策略，分析 Scavenge 和 Mark-Sweep-Compact 的实现细节，探索 V8 的优化之道。这是一场从内存分配到高效回收的完整旅程，带你理解 V8 的 GC 核心。🚀


---

## 1. 开端：V8 垃圾回收的背景与重要性

V8 是 JavaScript 的高性能引擎，其垃圾回收机制负责管理内存，清理无用对象，确保程序运行流畅。JavaScript 的动态性导致对象频繁创建与销毁，GC 必须高效处理这些内存分配。

**为何重要**：V8 通过新生代与老生代的世代分治，以及标记-清除与标记-整理算法，优化了内存使用与回收效率。这种设计减少了内存泄漏和停顿时间，是 V8 高性能的关键。

---

## 2. 算法基础：标记-清除与标记-整理

V8 的垃圾回收基于两大算法：标记-清除（Mark-Sweep）和标记-整理（Mark-Compact）。

- **标记-清除**：
  - **原理**：从根对象（如全局对象、栈变量）开始，标记所有可达对象，未标记的对象视为垃圾，直接清除。
  - **底层细节**：V8 使用 `MarkingState` 维护标记位图（Bitmap），通过深度优先搜索（DFS）标记内存块，`Sweep` 阶段释放未标记空间。
  - **适用场景**：适合新生代的短存活对象，快速回收但会产生碎片。

- **标记-整理**：
  - **原理**：在标记-清除后，将存活对象整理到连续内存区域，消除碎片。
  - **底层细节**：V8 的 `CompactingVisitor` 移动对象，更新指针（`Relocation`），通过 `Page` 级别的内存整理压缩空间。
  - **适用场景**：适合老生代的长存活对象，解决碎片问题但移动成本高。

**协同基础**：标记-清除为主，标记-整理为辅，分别应对新生代和老生代的回收需求。

---

## 3. 世代分治：新生代与老生代的内存管理

V8 将堆内存分为新生代（Young Generation）和老生代（Old Generation），采用世代回收策略：
- **新生代**：
  - **内存分配**：大小较小（默认 1-8MB），分为 From 和 To 两个半区，用于短生命周期对象。
  - **回收策略**：Scavenge 算法，存活对象从 From 复制到 To，未存活对象丢弃。
  - **为何双半区**：Cheney 算法利用双半区快速复制，翻转 From/To 角色，避免碎片。
- **老生代**：
  - **内存分配**：大小较大（默认 64MB+），存储长生命周期对象。
  - **回收策略**：主要使用标记-清除，空间不足或碎片过多时触发标记-整理。

**分治逻辑**：新生代快速回收短存活对象，老生代深度处理持久对象，减少 GC 频率与停顿时间。

---

## 4. 回收器的协作：Scavenge 与 Mark-Sweep-Compact

V8 使用两个垃圾回收器协同工作：
- **Scavenge（新生代回收器）**：
  - **实现原理**：基于 Cheney 算法，双半区复制。存活对象从 From 复制到 To，翻转半区角色。
  - **底层细节**：`Scavenger` 类扫描根对象（如栈引用），通过 `CopyObject` 函数移动存活对象，更新指针。  
  - **晋升机制**：存活对象经历一定次数（默认 2 次）回收后，通过 `PromoteYoungObjects` 晋升到老生代。

- **Mark-Sweep-Compact（老生代回收器）**：
  - **实现原理**：  
    - **标记-清除**：标记存活对象，清除垃圾，是老生代主要方式。  
    - **标记-整理**：碎片过多时触发，整理存活对象到连续区域。  
  - **底层细节**：  
    - `MarkingVisitor` 使用 DFS 标记，`IncrementalMarking` 分阶段标记减少停顿。  
    - `Sweep` 释放空间，`Compact` 通过 `RelocationTable` 移动对象。  
  - **触发条件**：标记-清除频繁运行，标记-整理由 `Heap::ShouldOptimizeForMemoryUsage()` 判断碎片率触发。

**协作逻辑**：Scavenge 快速清理新生代，Mark-Sweep 为主回收老生代，Mark-Compact 辅助优化碎片。

---

## 5. 优化闭环：V8 对垃圾回收的性能改进

V8 对 GC 进行了多项优化，提升性能与用户体验：
- **增量标记**：将标记分片执行（如 5ms 时间片），通过 `IncrementalMarking` 减少主线程停顿。
- **并行回收**：新生代的 `ParallelScavenge` 和老生代的 `ParallelSweep` 使用多线程，分配 `Worker` 线程利用多核 CPU。
- **写屏障**：`Dijkstra Write Barrier` 记录新生代到老生代的指针，存入 `StoreBuffer`，确保晋升对象可达。
- **延迟清理**：`IdleTask` 在空闲时执行增量 GC，降低高峰期压力。
- **内存压缩**：标记-整理的 `CompactingVisitor` 通过 `Page` 级别整理，减少碎片。

**优化效果**：增量和并行减少停顿时间至微秒级，写屏障提升回收精准性，形成高效闭环。

---

## 6. 启示与总结：垃圾回收的实践

- **减少短生命周期对象**：新生代频繁回收：
  ```javascript
  // Bad Case: 频繁创建临时对象
  for (let i = 0; i < 1000; i++) {
    const obj = { index: i };
  }
  ```
  **建议**：重用对象（如单例），减少 Scavenge 压力。

- **优化老生代内存**：标记-清除为主，标记-整理成本高：
  ```javascript
  const cache = [];
  function addCache() { cache.push(new Array(1000)); }
  ```
  **建议**：定期清理缓存（如 `cache.length = 0`），避免碎片触发 Mark-Compact。

- **利用 WeakMap 延迟回收**：生产中处理临时引用：
  ```javascript
  const weakMap = new WeakMap();
  const obj = {};
  weakMap.set(obj, 'data');
  ```
  **建议**：用 WeakMap 存储临时数据，GC 自动回收无用键值对。

**总结**：V8 的 Scavenge、Mark-Sweep 和 Mark-Compact 协同回收，优化如增量标记提升性能。理解其原理，能让你更精准地优化内存管理。

---

## 总结：从分配到回收的旅程

V8 的垃圾回收通过世代分治与算法优化，将内存管理变为高效流程。Scavenge 快速清理新生代，Mark-Sweep-Compact 深度管理老生代，协作形成闭环。这是一个从内存分配到回收优化的完整链条，每一步都不可或缺。理解这一过程，你会更从容地优化 JavaScript 性能。下次创建对象时，想想这背后的幕后逻辑吧！💡


---
tags: [React, Fiber, Reconciliation, Scheduler, Concurrent Mode, 性能优化]
category: React
date: 2022-05-20
title: 我不知道的 React:Fiber 架构如何重塑更新流程
desc: 深入 React Fiber 架构，理解其如何通过可中断渲染、优先级调度和双缓冲技术解决旧版 React 的性能瓶颈，并开启并发特性。
slug: react-03
---

## Fiber 架构的起源：告别阻塞

在 React 16 之前，React 的更新过程（称为 Stack Reconciliation，栈调和）是同步且递归的。当一个状态更新触发时，React 会一口气遍历整个组件树，计算差异并更新 DOM。对于复杂的应用，这个过程可能耗时很长（例如超过 16ms），导致主线程被阻塞，用户会感觉到页面卡顿或掉帧，尤其是在动画或用户输入期间。

**传统栈调和的痛点**: 
- **不可中断**: 一旦开始，必须等待整个更新完成，无法响应紧急任务。
- **无优先级**: 所有更新一视同仁，无法区分用户交互和后台任务。

为了解决这些问题，React 团队重写了核心的调和算法，引入了 **Fiber 架构**。

**Fiber 的核心思想**: 将原本不可中断的渲染/更新任务，拆分成一系列微小的、可中断的**工作单元 (Fiber 节点)**。React 可以根据可用时间执行一部分工作单元，然后暂停，将控制权交还给浏览器（用于处理更高优先级的任务，如用户输入），之后再恢复执行。这使得渲染过程变得**异步**和**可中断**。

## Fiber 节点的结构与作用

Fiber 不仅仅是一种算法思想，也是一种数据结构。

- **Fiber 节点**: 每个 React 元素（组件、DOM 节点等）在 Fiber 架构中都有一个对应的 Fiber 节点。它像一个链表节点，包含了组件的类型、状态、Props、副作用标记 (`effectTag`)，以及指向其父节点 (`return`)、子节点 (`child`) 和兄弟节点 (`sibling`) 的指针。
- **工作单元**: 每个 Fiber 节点也代表一个工作单元。React 通过遍历这些 Fiber 节点（从根节点开始，深度优先）来执行调和工作。
- **链表遍历替代递归**: 通过指针连接，Fiber 将原来的递归遍历改为了可以在内存中随时暂停和恢复的链表遍历。

## React 更新流程的"两阶段"革命

Fiber 架构将原本单一的更新过程，拆分成了两个主要阶段：

1.  **Render/Reconciliation Phase (渲染/调和阶段)**
    *   **任务**: 在这个阶段，React 遍历 Fiber 树（从触发更新的节点开始），计算出需要进行的变更（比如哪些节点需要插入、更新或删除，哪些组件需要调用生命周期方法或 `useEffect`）。它会构建一棵"Work-in-Progress"的 Fiber 树来表示新的状态。
    *   **核心特点**: **异步、可中断**。React 可以在这个阶段暂停工作，去处理更高优先级的任务，或者因为时间片用完而暂停，稍后再恢复。
    *   **无副作用**: 这个阶段**不会**执行任何 DOM 操作或其他用户可见的副作用。它纯粹是在内存中进行计算。

2.  **Commit Phase (提交阶段)**
    *   **任务**: 当 Render 阶段完成后，React 就得到了所有需要执行的变更列表。Commit 阶段负责**一次性地**将这些变更应用到实际的 DOM 上。这包括执行 DOM 插入、更新、删除操作，以及调用 `useLayoutEffect` 的回调函数和类组件的 `componentDidMount`/`componentDidUpdate` 等生命周期方法。
    *   **核心特点**: **同步、不可中断**。这个阶段必须一口气完成，以确保 DOM 的一致性，避免用户看到渲染不完全的中间状态。

这种两阶段分离是 Fiber 实现可中断渲染的关键。

## 时间分片与优先级调度

Fiber 架构的核心能力依赖于**时间分片 (Time Slicing)** 和**优先级调度 (Priority Scheduling)**，这两者通常由 React 内置的 **Scheduler (调度器)** 包来协调。

- **时间分片**: 
    *   **原理**: Scheduler 利用浏览器提供的机制（早期用 `requestIdleCallback`，现在主要基于 `MessageChannel` 实现更高精度的调度）来获取每一帧的空闲时间。
    *   **执行**: 在 Render 阶段，React 只在浏览器有空闲时间时才执行 Fiber 工作单元。如果一个工作单元执行完后发现时间不够了，或者有更高优先级的任务插队，它就会暂停，将控制权交还给浏览器，等到下一帧或空闲时再继续。
    *   **效果**: 保证了即使有复杂的后台更新任务在进行，浏览器也能及时响应用户输入或执行动画，保持界面流畅。
- **优先级调度**: 
    *   **原理**: 不是所有更新都同等重要。用户输入（如打字）的反馈需要立即响应，而后台数据加载的更新则可以稍等。Scheduler 为不同的更新任务分配不同的优先级（例如，`ImmediatePriority`, `UserBlockingPriority`, `NormalPriority`, `IdlePriority`，在 React 18 中这套机制演变成了更精细的 Lanes 模型）。
    *   **执行**: 调度器会优先处理高优先级的任务。如果一个低优先级的 Render 任务正在进行中，一个高优先级的更新来了，Scheduler 会中断低优先级任务，先完成高优先级更新，然后再回来继续（或重新开始）低优先级任务。
    *   **效果**: 确保了关键交互的即时响应。

## 双缓冲技术 (Double Buffering)

为了在可中断的 Render 阶段和不可中断的 Commit 阶段之间平滑过渡，并避免用户看到不完整的 UI，Fiber 使用了**双缓冲技术**：

- **两棵树**: React 在内存中同时维护两棵 Fiber 树：
    - **当前树 (Current Tree)**: 代表当前已经渲染到屏幕上的 UI 状态。
    - **工作进行中树 (Work-in-Progress Tree, WIP Tree)**: 在 Render 阶段构建的，代表即将渲染的新 UI 状态。
- **构建过程**: Render 阶段的所有计算和变更标记都在 WIP 树上进行，不影响当前屏幕显示的 UI。
- **切换**: 当 Render 阶段完成，并且 React 决定要将变更应用到屏幕时（进入 Commit 阶段），它会原子性地将 WIP 树切换为当前树（通过改变一个指向根节点的指针），然后根据这棵新树的信息去更新 DOM。
- **复用**: 上一次的"当前树"在下一次更新时，会被复用作为新的 WIP 树的起点，减少内存分配开销。

双缓冲确保了用户界面总是在一个完整的、一致的状态之间切换。

## Fiber 与 Vue 更新机制对比

React Fiber 的思路与 Vue 的更新机制有本质不同：

- **React (Fiber)**:
    - **核心**: 运行时调度 + VDOM Diff。
    - **机制**: 通过 Fiber 架构实现可中断的、基于优先级的运行时调度。每次更新理论上仍需协调整个（或部分）组件树，依赖 Diff 找出变更。优化依赖 `memo`, `useMemo` 等手动操作或 React Compiler (React 19+)。
    - **优势**: 灵活性高，对并发渲染、复杂异步场景支持更好。
- **Vue**: 
    - **核心**: 编译时优化 + 响应式追踪。
    - **机制**: Vue 在编译阶段分析模板，找出静态和动态部分。运行时通过响应式系统精确知道哪个数据变化了，只触发依赖该数据的组件进行更新，并进行靶向 DOM 操作或小范围 Diff（如列表使用双端 Diff）。
    - **优势**: 更新粒度更细，默认性能通常较好，心智负担较低。

**总结对比**: React Fiber 侧重于通过**运行时调度**来管理更新过程，实现可中断和优先级，适合复杂交互和并发场景；Vue 侧重于通过**编译时分析和响应式系统**来**最小化更新范围**，默认性能好，开发体验更平滑。

## Fiber 的价值与未来

Fiber 架构不仅仅是一次性能优化，它为 React 的未来发展奠定了基础：

- **并发特性 (Concurrent Features)**: Fiber 的可中断和优先级调度能力，是实现 React 18 并发特性（如 `useTransition`, `useDeferredValue`）的基石，让 React 应用能更智能地处理渲染，保持 UI 流畅。
- **Suspense**: Fiber 使得 Suspense 功能（用于数据获取或代码分割时的加载状态管理）的实现更加自然和强大，尤其是在与 RSC 结合时。

理解 Fiber 架构，有助于我们理解现代 React 的性能特点、并发模式的工作原理，以及如何更好地编写高性能的 React 应用。
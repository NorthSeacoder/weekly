---
tags: [React, 前端开发, RSC, SSR, 性能优化, Suspense, Hydration]
category: React
date: 2024-05-29
title: 我不知道的 React:服务器组件、SSR 与水合之谜
desc: 深入剖析 React 服务器组件 (RSC) 与 SSR 的本质区别，揭开“水合”过程的神秘面纱及其优化方向。
slug: react-018
---

React 的世界总在进化，服务器组件 (RSC) 的出现更是搅动了一池春水。很多人把它和服务器端渲染 (SSR) 搞混，再加上个“水合”(Hydration)，简直让人头大。🤯 今天，咱们就来彻底厘清这几个概念。

## 服务器组件 (RSC) 解密 💡

先问个基础问题：“RSC 到底是什么？”

**服务器组件 (React Server Components, RSC)** 是一种新型的 React 组件。顾名思义，**它只在服务器上运行和渲染**。

它的设计目标很明确：

1.  **减少客户端 Bundle 体积**: 因为 RSC 的代码（包括其依赖）压根不会被下载到浏览器，客户端包自然就小了，加载更快。🚀
2.  **直接访问后端资源**: 在服务器上运行，意味着 RSC 可以像写后端代码一样，直接访问数据库、文件系统或内部 API，不需要额外搞一套 API 请求。数据获取更直接、高效。
3.  **自动代码分割**: RSC 天然支持按需加载，只有当导航到需要某个 RSC 的页面时，对应的代码才会被处理。
4.  **与 Suspense 深度集成**: RSC 可以直接在服务端 async/await 数据获取。这与 React.Suspense 完美配合。当 RSC 在获取数据时 await，服务器不会阻塞，而是利用 HTTP 流式传输，先将 Suspense 定义的加载状态（fallback）发送给客户端展示，待数据准备好后，再将实际内容作为后续数据块发送。这允许在服务端就决定渲染加载状态，并将结果流式传输到客户端，无需客户端等待数据返回后再渲染，进一步优化加载体验。

简单说，RSC 是一种在构建时或请求时，在服务器环境执行，并将其渲染结果（一种特殊的中间格式，不是 HTML）发送给客户端的组件。它本身不具备交互能力。

## RSC vs. 普通组件 (客户端组件)

为了搞懂 RSC，最好的办法是跟我们熟悉的“普通组件”（现在官方称之为 **客户端组件, Client Components**）做个对比：

| 特性         | 服务器组件 (RSC)                   | 客户端组件 (Client Component)         |
| :----------- | :--------------------------------- | :------------------------------------ |
| **运行环境** | **服务器** (构建时或请求时)        | **浏览器** (客户端)                   |
| **状态 (State)** | ❌ 不能使用 `useState`, `useReducer` | ✅ 可以使用                           |
| **生命周期/Effects** | ❌ 不能使用 `useEffect`, `useLayoutEffect` | ✅ 可以使用                           |
| **浏览器 API** | ❌ 不能访问 `window`, `document`   | ✅ 可以访问                           |
| **交互性**   | ❌ 不能添加事件监听 (如 `onClick`) | ✅ 可以添加事件监听，处理用户交互     |
| **后端访问** | ✅ 可以直接访问数据库、文件系统等  | ❌ 需要通过 API 请求                 |
| **与 Suspense** | ✅ 服务端数据获取天然配合 Suspense | ✅ 可以在客户端配合 Suspense 处理异步 |
| **发送到客户端** | 渲染结果 (特殊格式: RSC Payload) | JavaScript 代码                       |

**关键区别**：RSC 牺牲了交互性和客户端状态管理能力，换来了更小的包体积、直接的数据访问能力以及与 Suspense 的丝滑结合。而客户端组件则负责处理用户交互和浏览器环境下的所有动态行为。两者通常需要配合使用。

## RSC vs. SSR 辨析 🤔

这是最容易混淆的地方：“RSC 和 SSR 有啥不一样？它们解决的问题有何不同？”

虽然都涉及服务器，但它们完全是两码事：

1.  **渲染目标与产物不同**:
    *   **SSR (Server-Side Rendering)**: 在服务器上将 React 组件渲染成 **HTML 字符串**。浏览器收到 HTML 后能立刻显示内容，对 SEO 和首屏加载（FCP）非常友好。
    *   **RSC (React Server Components)**: 在服务器上渲染成一种 **特殊的中间格式 (RSC Payload)**。这个格式本质上是一种**序列化的虚拟 DOM 指令流**，描述了 UI 结构、Props 以及对客户端组件（标记为 `Client Component`）的引用和其所需的 props。它**不是直接可用的 HTML**，而是需要客户端的 React runtime 来解析和渲染到 DOM 中（或者与 SSR 生成的 HTML 结合）。

2.  **解决的问题不同**:
    *   **SSR 主要解决**: **首屏性能** (快速看到内容) 和 **SEO** (搜索引擎能抓取到内容)。SSR 输出的 HTML 在客户端还需要“水合”才能变得可交互。
    *   **RSC 主要解决**: **客户端 JavaScript 负担** (减少 Bundle 大小)、**数据获取瀑布流** (在服务器提前获取数据并与 Suspense 结合)、以及 **后端资源访问的便捷性**。RSC 本身不直接改善 FCP 或 SEO（但可以和 SSR 配合）。通过与 Suspense 和流式传输的结合，RSC 可以在数据加载时先发送骨架屏或加载指示器，待数据到达后再发送实际内容，这一切都发生在同一个请求响应流中，分为不同的数据块，从而改善感知性能。

3.  **组件类型限制**:
    *   **SSR**: 可以渲染包含客户端逻辑（如 `useState`, `useEffect`）的组件，但这些逻辑在服务器端不会执行交互效果，只输出静态 HTML。
    *   **RSC**: 严格区分服务器组件和客户端组件。服务器组件不能包含客户端逻辑。

**简单总结**: SSR 是把整个应用（或页面）在服务器“快照”成 HTML；RSC 是一种组件级的服务器执行策略，通过其独特的 Payload 格式，优化资源加载、数据流和开发者体验。它们可以，也经常被一起使用 (例如 Next.js App Router)。

## “水合”(Hydration) 过程详解 💧

聊 SSR 必然绕不开“水合”。那么，“水合具体指什么操作？” **需要明确的是，传统意义上的水合主要针对 SSR 生成的 HTML**。

**水合 (Hydration)**，可以理解为给服务器渲染出的“骨架”（静态 HTML）注入“灵魂”（JavaScript 交互能力）的过程。

具体步骤通常是这样的：

1.  **服务器渲染 (SSR)**: 服务器运行 React 代码，生成页面的 HTML 结构，发送给浏览器。
2.  **浏览器显示**: 浏览器收到 HTML，立刻渲染出静态页面内容。用户能很快看到界面，但此时按钮点击等交互是无效的。
3.  **加载 JavaScript**: 浏览器开始下载页面所需的 JavaScript 包 (包含 React 库和你的客户端组件代码)。
4.  **水合阶段**:
    *   JavaScript 加载并执行后，React 会接管由 SSR 生成的静态 DOM 树。
    *   它会在内存中**重新构建客户端组件树的 VDOM 结构**。
    *   然后，React 会**将这个 VDOM 与服务器发送的 HTML 的 DOM 结构进行比对**，以确保一致性，并**将 JavaScript 中的事件监听器 (event listeners) 附加到对应的 DOM 节点上**，同时恢复组件状态。
    *   这个过程就像给干燥的海绵（静态 HTML）加水（JavaScript），让它恢复活力（变得可交互），因此得名“水合”。

**水合的代价**: 水合并非没有成本。它不仅需要下载、解析和执行客户端 JavaScript，还需要 React 在客户端**重新构建 VDOM 结构**，并执行 **VDOM 与真实 DOM 的比对**过程。这个 VDOM 构建和比对过程本身就有计算开销，特别是在复杂页面上，**可能会阻塞主线程**，延迟页面的可交互时间 (TTI)，影响用户体验。

**那 RSC 需要水合吗？** 严格来说，RSC 本身输出的不是 HTML，而是 RSC Payload。客户端 React 接收到这个 Payload 后，会将其解析并更新 VDOM。这个过程更像是**客户端渲染的更新或 VDOM 的直接构建**，而不是传统意义上对静态 HTML 的“水合”（即 VDOM 与 HTML 的比对和事件附加）。然而，当 RSC 和 SSR **结合使用时**（例如，一个页面同时使用了 SSR 输出 HTML 骨架，并且其中某些部分由 RSC 提供内容，另一些部分是客户端组件），由 SSR 生成的那部分 HTML 骨架（尤其是包含客户端组件的部分）**仍然需要水合**，以附加事件监听器和激活交互。RSC 的优势在于，它渲染的部分（纯服务端内容）其对应的 DOM 更新更高效，因为它直接提供了 VDOM 指令，避免了对这部分内容的传统水合比对开销，从而**减少了整体的水合负担**。

**水合的优化探索**: 正因为水合的成本，社区一直在探索优化方案。比如：
*   **Partial Hydration** (部分水合，如 Astro Islands 架构): 只对页面中真正需要交互的“岛屿”（组件）进行水合，其余保持为静态 HTML，显著减少客户端 JS 执行量。
*   **Resumability** (可恢复性，如 Qwik 框架): 旨在**完全消除**传统的水合步骤。它通过在服务端序列化应用的精细状态和事件监听器信息，使得客户端 JS 可以直接“恢复”执行逻辑，而不是“重新附加”所有事件，从而实现近乎即时的可交互性。

## 优势与场景选择 🎯

那么，什么时候用 RSC，什么时候用 SSR，或者两者结合？

*   **SSR 的优势**:
    *   **极佳的首屏加载速度 (FCP)**：用户能快速看到内容。
    *   **良好的 SEO**: 搜索引擎可以直接抓取渲染后的 HTML。
    *   **适用场景**: 内容驱动型网站（博客、新闻门户、电商产品页），对首屏性能和 SEO 要求高的场景。

*   **RSC 的优势**:
    *   **显著减少客户端 JS 体积**: 提升后续加载和交互性能。
    *   **简化数据获取逻辑**: 组件可以直接访问后端，并与 Suspense 良好集成。
    *   **自动代码分割**: 按需加载组件代码。
    *   **适用场景**:
        *   需要展示大量非交互式内容的组件（如静态文章、产品信息块）。
        *   需要直接访问后端数据或服务的组件。
        *   复杂应用中，希望将“展示型”组件和“交互型”组件分离，优化整体性能。

*   **RSC + SSR 结合 (现代框架如 Next.js App Router 的默认模式)**:
    *   取长补短：利用 SSR 实现快速首屏和 SEO，利用 RSC 减少客户端 JS 负担、优化数据流和利用 Suspense 提升加载体验。SSR 输出 HTML 骨架，RSC 填充内容，客户端组件负责交互，各司其职。
    *   **适用场景**: 大部分现代 Web 应用，尤其是需要高性能、良好用户体验和可维护性的复杂项目。

**选择策略**:

*   如果你的应用主要是静态内容展示，对 SEO 要求高，**SSR 是基础**。
*   如果你的应用交互复杂，客户端 JS 负担重，或者希望简化数据获取并利用 Suspense，**引入 RSC 会带来巨大好处**。
*   现代框架通常推荐 **RSC + SSR + 客户端组件** 的混合模式，根据组件的具体职责（展示、交互、数据访问）选择最合适的类型。

理解 RSC、SSR、水合及其优化的本质区别与联系，是驾驭现代 React 开发的关键一步。希望这次的剖析能帮你拨开迷雾！✨

---

## 核心问题

1.  **RSC 和 SSR 最本质的区别是什么？它们各自的产物是什么？**
    *   **答案**: SSR 在服务器将组件渲染成 **HTML 字符串**，目标是优化首屏加载 (FCP) 和 SEO。RSC 在服务器执行并将结果渲染成一种**特殊的中间格式 (RSC Payload)**，它本质是序列化的 VDOM 指令流，目标是减少客户端 JS 体积、简化数据获取并与 Suspense 集成，它不直接输出 HTML。
2.  **传统意义上的“水合”主要发生在什么场景下？RSC 自身需要水合吗？**
    *   **答案**: 传统水合主要发生在 **SSR 场景**下，目的是让服务器渲染的静态 HTML 变得可交互。RSC 本身输出的是 Payload 而非 HTML，其内容由客户端 React 解析并更新 VDOM，更像客户端更新而非传统水合。但在 RSC 与 SSR 结合使用时，由 SSR 渲染出的包含客户端组件的 HTML 部分**仍然需要水合**。
3.  **水合过程可能带来哪些性能瓶颈？提及至少一种优化水合的技术方向。**
    *   **答案**: 水合需要在客户端执行 JS、重建 VDOM、比对 DOM 并附加事件，这些操作可能**阻塞主线程**，延迟 TTI。优化方向包括 **Partial Hydration** (只水合交互部分) 或 **Resumability** (如 Qwik，尝试消除水合，直接恢复执行)。

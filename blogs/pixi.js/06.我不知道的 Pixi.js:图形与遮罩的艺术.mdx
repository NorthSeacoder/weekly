---
tags: [前端开发, Pixi.js, JavaScript, 图形绘制, 遮罩技术]
category: Pixi.js
date: 2024-07-06
title: 我不知道的 Pixi.js:图形与遮罩的艺术
desc: 探索 Pixi.js 图形与遮罩的实现，从绘制路径到裁剪效果的幕后逻辑。
slug: pixi-js-06
---


Pixi.js 的图形绘制与遮罩功能是开发者手中的创意工具，能轻松打造动态形状和复杂裁剪效果。从绘制圆形到实现局部高亮，这些功能如何在引擎中运转？今天，我们将从图形绘制的基础开始，逐步揭开 Pixi.js 的图形与遮罩机制，深入分析路径渲染和遮罩实现的幕后逻辑。这是一场从线条到效果的完整旅程，带你理解引擎的视觉核心。🚀


---

## 1. 图形的起点:绘制路径的开端

Pixi.js 的图形绘制从 `Graphics` 类开始。这个类是矢量图形的入口，让开发者可以创建各种形状。你可以简单地绘制一个红色圆形:

```javascript
const graphics = new PIXI.Graphics();
graphics.beginFill(0xff0000);
graphics.drawCircle(100, 100, 50);
graphics.endFill();
app.stage.addChild(graphics);
```

**幕后逻辑**:调用 `drawCircle` 时，Pixi.js 将圆形分解为一系列三角形路径，准备渲染。`beginFill` 设置填充颜色，`endFill` 标志路径完成。这一过程将静态指令转化为屏幕上的像素，开辟了图形创作的舞台。

**关键衔接**:绘制路径是图形的基础，接下来需要了解它如何变成可见画面。

---

## 2. 路径的呈现:从指令到渲染

路径定义后，Pixi.js 需要将其渲染到屏幕上。无论是圆形还是多边形，引擎会将这些路径三角化——分解成小三角形，确保 GPU 能高效处理。填充颜色和描边通过着色器应用到这些三角形上，最终呈现出完整的图形。

**渲染过程**:Pixi.js 将路径数据（如顶点坐标）送入 WebGL 的绘制管道，着色器根据填充属性计算每个像素的颜色。例如，一个红色圆形的着色器会为所有三角形区域填充统一的颜色值。这种矢量方法让图形在缩放时保持清晰，但每次更新路径都需要重新计算，增加了计算成本。

**向前一步**:路径渲染生成图形，如何控制其可见区域？遮罩登场。

---

## 3. 遮罩的裁剪:定义可见的边界

遮罩是 Pixi.js 中控制图形可见性的工具，能裁剪对象的显示区域。例如，将一个图像限制在圆形范围内:

```javascript
const sprite = new PIXI.Sprite(texture);
const mask = new PIXI.Graphics();
mask.beginFill(0x000000);
mask.drawCircle(200, 200, 100);
mask.endFill();
sprite.mask = mask;
app.stage.addChild(sprite, mask);
```

**实现原理**:遮罩利用 WebGL 的 stencil buffer（模板缓冲区）。引擎先绘制遮罩形状，将其记录在缓冲区中，然后只渲染目标对象与遮罩区域匹配的部分。遮罩的颜色无关紧要，仅形状起作用。这一过程让开发者能灵活裁剪画面。

**连接前后**:图形绘制创建内容，遮罩裁剪其边界。两者的性能如何？

---

## 4. 性能的权衡:图形与纹理的选择

图形绘制和遮罩技术带来灵活性，但性能表现因场景而异。矢量图形（`Graphics`）和纹理（`Sprite`）各有特点:

- **矢量图形**:动态性强，适合实时变化的形状，如进度条；缩放无损，但路径计算依赖 CPU，复杂图形可能拖慢帧率。  
- **纹理**:预渲染图像由 GPU 直接处理，渲染快，适合静态内容，但内存占用高，动态修改困难。  

遮罩则增加额外的 stencil 测试开销，复杂遮罩（如多边形）比简单形状（如矩形）更耗资源。

**逻辑递进**:绘制生成图形，遮罩定义边界，性能影响选择。如何结合使用？

---

## 5. 协同的应用:图形与遮罩的实战结合

图形与遮罩的结合能创造丰富效果。假设我们要在一个图像上实现“探照灯”效果:

```javascript
const app = new PIXI.Application({ width: 400, height: 400 });
document.body.appendChild(app.view);

const texture = PIXI.Texture.from('image.jpg');
const sprite = new PIXI.Sprite(texture);
sprite.position.set(0, 0);

const mask = new PIXI.Graphics();
mask.beginFill(0x000000);
mask.drawCircle(200, 200, 100);
mask.endFill();
sprite.mask = mask;

app.stage.addChild(sprite, mask);
```

**分析**:`Graphics` 绘制圆形作为遮罩，`Sprite` 提供图像内容。引擎先渲染图像到缓冲区，再用圆形遮罩裁剪，只显示圆内区域。这种协作让效果既动态又高效。

**闭环连接**:绘制路径生成图形，渲染呈现画面，遮罩裁剪边界，性能指导选择，最终结合实现效果。

---

## 6. 启示的收获:图形与遮罩的智慧

Pixi.js 的图形与遮罩机制是一个精密的设计:
- **路径绘制** 创建形状。
- **渲染流程** 呈现画面。
- **遮罩裁剪** 控制边界。
- **性能权衡** 影响选择。
- **协同应用** 实现创意。

**开发启示**:想优化效果？用简单遮罩减少开销；动态图形选 `Graphics`，静态用纹理；结合两者的应用能提升视觉层次。Pixi.js 将复杂的渲染逻辑封装在直观接口后，让你轻松实现创意。

---

## 总结:从线条到效果的旅程

Pixi.js 的图形与遮罩技术将简单的线条转化为复杂的视觉效果。路径绘制奠基，渲染呈现，遮罩裁剪，性能选择，最终结合成完整画面。这是一个从基础到应用的精密过程，每一步都不可或缺。理解这一机制，你会更从容地用 Pixi.js 打造动态视觉。下次绘制图形或应用遮罩时，想想这背后的幕后逻辑吧！💡

---
tags: [前端开发, 浏览器原理, 渲染优化, CSS]
category: 浏览器原理
date: 2024-09-09
title: 我不知道的浏览器:页面渲染的完整流程与优化关键
desc: 剖析浏览器渲染流水线，揭秘 CSSOM、分层、光栅化与性能优化。
slug: browser-04
---

### 1. 浏览器渲染页面的整体流程

浏览器渲染页面是一个复杂的过程，旨在将 HTML、CSS 和 JavaScript 转化为用户可见的界面。其核心流程包括解析资源、构建数据结构、计算布局、绘制图层和最终合成显示。主线程负责解析和布局等任务，而合成线程则优化绘制与动画效果。这一过程直接影响页面加载速度和交互体验，尤其在复杂页面或动态内容中。

---

### 2. 渲染流水线的具体步骤

渲染流水线分为八个关键步骤，每一步都对性能有重要影响：

1. **解析 HTML 和 CSS, 构建 DOM 和 CSSOM**
    - 浏览器首先解析 HTML 文件生成 DOM 树，同时解析 CSS 文件（包括内联样式和外部样式表）生成 CSSOM（CSS Object Model）。CSSOM 是 CSS 样式的树状表示，包含选择器、声明和层级关系，为后续渲染提供样式信息。
    - 解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。
    - 如果主线程解析到 link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。
    - 如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。
2. **样式计算**
    - 主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style
    - 在这一过程中，很多预设值会变成绝对值，比如 red 会变成 rgb(255,0,0)；相对单位会变成绝对单位，比如 em 会变成 px
    - 这一步完成后，会得到一棵带有样式的 DOM 树。
3. **布局**
    - 布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。
    - 大部分时候，DOM 树和布局树并非一一对应。
    - 比如 display:none 的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。
4. ** 分层**
    - 主线程会使用一套复杂的策略对整个布局树中进行分层(layers)。
    - 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。
    - 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过 will-change 属性更大程度的影响分层结果。
5. **绘制**
    - 主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。
    - 绘制指令集在浏览器中是以图层树(layer tree)的形式存在。
    - 图层树的根节点是布局树的根节点。
    - 图层树的每个节点都包含一个绘制指令集。
    - 绘制完成后，后续步骤交给合成线程。
6. **分块**
    - 合成线程首先对每个图层进行分块，将其划分为更多的小区域。
    - 它会从线程池中拿取多个线程来完成分块工作。
7. **光栅化**
    - 合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。
    - GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。
    - 光栅化的结果，就是一块一块的位图
8. **Paint**
    - 合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。
    - 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。
    - 变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。
    - 合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。

---

### 3. CSSOM 的作用与操作性

CSSOM 是 CSS 样式的树状结构，包含样式规则及其层级关系。开发者可通过 JavaScript 获取或修改 CSSOM，例如：

```javascript
const styleSheet = document.styleSheets[0];
styleSheet.cssRules[0].style.color = 'blue';
```

也可通过 `getComputedStyle(element)` 获取计算后的样式值。但频繁操作 CSSOM 可能触发 Reflow 或 Repaint，例如修改样式导致布局重算。建议批量操作以减少性能开销。

---

### 4. 合成线程与主线程的协作

合成线程专门处理图层合成和动画效果，独立于主线程运行。主线程负责解析 HTML、构建 DOM 和 CSSOM、执行 JavaScript、计算布局和绘制图层，完成后将图层移交至合成线程。合成线程利用 GPU 加速，将图层合并为最终画面，输出到屏幕。

二者通过事件循环协作：主线程完成绘制后，合成线程接管平滑滚动或动画任务。例如，CSS 属性如 transform 和 opacity 可直接由合成线程处理，不触发主线程的 Reflow 或 Repaint，从而提升效率。

---

### 5. Reflow、Repaint 及 Transform 的性能分析

Reflow（重排）是指重新计算布局，通常由元素尺寸或位置变化触发，例如修改 `width` 或 `height`,从步骤 3 开始
Repaint（重绘）是更新视觉外观，如更改 `background-color`，不涉及布局，成本较低。从步骤 5 开始

Transform 的性能因场景而异：

-   **高效场景**: 如 `transform: translateX(10px)`，仅改变元素位置，由合成线程直接处理，不触发 Reflow 或 Repaint。从步骤 8 开始
-   **低效场景**: 若 transform 涉及复杂嵌套或影响其他元素，可能间接触发 Reflow。

读取 style（如 `element.style.width`）可能导致 Reflow，因浏览器需强制计算当前布局以确保值准确性，尤其在样式未缓存时。

---

### 6. 属性值计算、包含块与优化建议

**属性值计算**分为以下步骤：

1. **声明值**: 从 CSS 规则提取原始值（如 `width: 50%`）。
2. **计算值**: 将相对单位转为绝对值（如 50% 转为 500px，基于包含块）。
3. **最终值**: 考虑浏览器约束（如最小宽度）生成实际值。

**包含块**（Containing Block）是元素定位和尺寸的参考基准：

-   `position: static` 或 `relative`：包含块是最近的块级祖先的内容框边缘。
-   `position: absolute`：包含块是最近的非 `static` 定位祖先的填充框边缘。
-   `position: fixed`：包含块是视口。

**优化建议**：

-   **减少 Reflow**: 批量修改样式，使用 transform 替代 `left` 或 `top`。
-   **谨慎使用 will-change**: 如 `will-change: transform` 可优化动画，但过多图层增加内存开销。
-   **监控性能**: 使用 Chrome DevTools 的 Layers 面板分析图层，识别 Reflow 和 Repaint 瓶颈。

掌握这些机制，能显著提升渲染效率 🚀。
